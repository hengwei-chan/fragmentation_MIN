def recurse(f_old, start, derivs, fraglist, signlist, sign, checked_list, level, temp_list):    #1st depth and on, finding intersection adding new
    """ 
    Recursive part of the pie
    
    Where funciton  builds layers and layers of fragments from interestions

    Parameters
    ----------
    f_old : list
        A list of primiatives for a specific fragment
    start : int
        The depth of intersections.  Always increasing.
    derivs : list
        List of derivates that keeps getting appended tol.l
    fraglist : list of lists
        List of fragment that gets generated by functions in the Fragmentation class. Does not change in this function.
    signlist : list
        List of coefficents
    sign : int
        New sign that is determined based on PIE
    """
    #print("\nLevel =:", level)
    print("start of recurse with frag:", f_old)
    for fj in range(start+1, len(fraglist)):
        print("\nchecking", f_old, "with", fraglist[fj])
        print("checked list:", checked_list)
        
        df_new = fraglist[fj].intersection(f_old)
        
        #if fj in checked_list and len(df_new) > 0:
        #    print("fj in checked list")
        #    continue
        
        if len(df_new) > 0:
            print("interstion:", df_new)
            print("temp list:", temp_list)
            #if df_new not in temp_list:
            #    print("intersection not in temp_list")
            #    temp_list.append(df_new)
            #    level = level+1
            #    checked_list = []
            #    print("New level so checked list = 0", checked_list)
            
            print("intersection found:", df_new)
            
            #add fj to checked list
            checked_list.append(fj)

            #add new deriv to list
            derivs.append(df_new)

            #change sign and add to coeff list
            df_newcoeff = sign * -1
            signlist.append(df_newcoeff)
            print("coeff:", df_newcoeff)

            #check for additional overlaps
            recurse(df_new, fj, derivs, fraglist, signlist, df_newcoeff, checked_list, level, temp_list)
    
    #print("start of recurse with frag:", f_old)
    #for fj in range(start, len(fraglist)):
    #    print("\nchecking", f_old, "with", fraglist[fj])
    #    print("checked list:", checked_list)
    #    if fj > start:
    #        df_new = fraglist[fj].intersection(f_old)
    #        print("fj", fj, "> start", start)
    #        if len(df_new) > 0:
    #            print("intersection found:", df_new)
    #            
    #            #add fj to checked list
    #            checked_list.append(fj)

    #            #add new deriv to list
    #            derivs.append(df_new)

    #            #change sign and add to coeff list
    #            df_newcoeff = sign * -1
    #            signlist.append(df_newcoeff)

    #            #check for additional overlaps
    #            recurse(df_new, fj, derivs, fraglist, signlist, df_newcoeff, checked_list)

def runpie(fraglist):
    """ 
    Runs the principle of inculsion-exculsion
    
    Parameters
    ----------
    fraglist : list of lists
        List of fragments that gets generated by functions in the Fragmentation class.

    Returns
    -------
    derivs : list
        List of derivatives created by prinicple on inclusion-exculusion
    signlist : list
        List of coefficents (1 or -1)
    """
    
    derivs = []
    signlist = []
    for fi in range(0, len(fraglist)):  #0th depth, just initial frags
        dfi = fraglist[fi]
        dfi_coeff = 1
        derivs.append(dfi)
        signlist.append(dfi_coeff)
        checked_list = []
        level = 0
        temp_list = []
        recurse(fraglist[fi], fi, derivs, fraglist, signlist, dfi_coeff, checked_list, level, temp_list)
    return derivs, signlist
